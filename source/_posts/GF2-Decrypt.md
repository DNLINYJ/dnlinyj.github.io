---
title: 少前2:追放 资源解密记录
date: 2023-10-05 19:04:16
tags:
---

> 本文仅供个人研究所用，不提供任何解密后的资源，侵删

最近，某个总是被人说药丸的游戏出了一个新游戏，闲的没事想看看资源结果被加密了(⊙ˍ⊙) 直接掏出珍藏已久的 IDA，干他 :)

## 1. global-metadata.dat 解密

一般来说像YM这种体量不大的厂商，一般只会在业务代码中写解密逻辑，不大可能在 Unity 源码里面塞解密和修改 global-metadata.dat 的读取结构 (点名某个厂商), 所以先把 il2cpp 的符号还原会看着舒服点。

先拿 010 Editor 看下文件，标准签名头没有修改 (AF 1B B1 FA)，但是后面的内容全部被加密了

![global-metadata_dat_1](global-metadata_dat_1.png)

启动游戏，Process Monitor看一眼，直接一眼丁真，鉴定为纯纯的传统派，这不就是把内容直接映射到内存然后解密吗，找到内存直接 dump 出来，再拿 il2cppdumper 把符号导出来就完事了 ᕕ(◠ڼ◠)ᕗ

![Alt text](image-1.png)

跟着堆栈走一圈，最终跟到了 NEP2.dll 里面，等解密完之后把内存 dump 出来，再把 4~8 字节的 SDK 版本号给他修一下就可以获得符号了 

![Alt text](image.png)

![Alt text](image-2.png)

(忘记截图了就来张压缩包的照片吧 -_- )

![Alt text](image-3.png)

## 2. AssetBundle 解密

有了符号，追AB包解密就轻松很多了 (^_^)

这次追放的AB包分为两个部分: 一个是存放在 `StreamingAssets\aa\StandaloneWindows64` 的未加密AB包，另一部分是放在 `LocalCache\Data\AssetBundles_Windows` 的加密AB包，这也是绝大部分游戏资源存放的地方

查看加密文件，有一个比较明显的规律，既有的字节没有加密，如下图中 `UnityFS` 的标准头中 `FS` 没有被加密，且部分版本号如 `2019.4.29f1` 中的 `19.4` 、`5.x.x` 中的 `5.x` 没有被加密。

根据一定数量的观察，发现规律基本一致，那么可以确实解密方式应该就是单纯的异或了

![Alt text](image-4.png)

补充：为什么是异或？因为大部分游戏厂商 `一开始` 都是这么做的，包括某个加密方式恶心的要死的厂商，一开始都用的是异或 ~~虽然现在也差不多()~~（︶^︶）

查看程序行为，发现并没有像标准 AssetBundle 文件逐个读文件头，而是直接读了一大片，这铁定是在内存解密了

![Alt text](image-5.png)

跟堆栈走一下，最后跟到了 `GameAssembly.dll + 0x511B90` 这个函数，看到 IDA 提示中的 `switch` 跳转，感觉大事不妙，果然，是**恶心的控制流平坦化，好像还套了不止一层 (╬▔皿▔)╯

![Alt text](image-6.png)

~~恶心的 CFG 一辈子都不会去跟的，就是看看内存直接硬套才能维持生活~~ 硬跟不行就看上一个调用的函数, 发现了一个有趣的东西，调用的时候直接把 buffer 传进去了，返回的时候解密完的 AssetBundle 直接在内存里等我们了()

![Alt text](image-7.png)

![Alt text](image-8.png)

直接内存 dump 出来比对一下，发现只有前面 `0x1000 * 8` 个字节被异或了，直接比对完写个解密程序就行了

(dump没截图，直接拿解密后的来比较了，左边为源文件，右边为解密后文件)

![Alt text](image-9.png)

直接拿 AssetStudio 加载，完美加载 (╹ڡ╹ )

![Alt text](image-10.png)

## 3. 总结

其实在AB包解密的时候，我直接硬钢 CFG 去了，根本没想过这玩意就一简单异或（囧），要不是朋友直接跟我说，我还傻乎乎在那里跟汇编呢 ()